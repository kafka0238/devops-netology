# Домашнее задание к занятию "3.7. Компьютерные сети, лекция 2"

1. На лекции мы обсудили, что манипулировать размером окна необходимо для эффективного наполнения приемного буфера участников TCP сессии (Flow Control). Подобная проблема в полной мере возникает в сетях с высоким RTT. Например, если вы захотите передать 500 Гб бэкап из региона Юга-Восточной Азии на Восточное побережье США. [Здесь](https://www.cloudping.co/grid) вы можете увидеть и 200 и 400 мс вполне реального RTT. Подсчитайте, какого размера нужно окно TCP чтобы наполнить 1 Гбит/с канал при 300 мс RTT (берем простую ситуацию без потери пакетов). Можно воспользоваться готовым [калькулятором](https://www.switch.ch/network/tools/tcp_throughput/). Ознакомиться с [формулами](https://en.wikipedia.org/wiki/TCP_tuning), по которым работает калькулятор можно, например, на Wiki.
    - **Необходимый размер окна равен: 37500**
    
1. Во сколько раз упадет пропускная способность канала, если будет 1% потерь пакетов при передаче?
    - **Пропускная способность канала упадет в 10 раз**

1. Какая  максимальная реальная скорость передачи данных достижима при линке 100 Мбит/с? Вопрос про TCP payload, то есть цифры, которые вы реально увидите в операционной системе в тестах или в браузере при скачивании файлов. Повлияет ли размер фрейма на это?
    - **Максимальная реальная скорость при линке 100 Мбит/с равна ~12 Мбайт/с**
    - **При увеличении фрейма, скорость передачи увеличиться, при уменьшении соответствено уменьшиться**

1. Что на самом деле происходит, когда вы открываете сайт? :)
На прошлой лекции был приведен сокращенный вариант ответа на этот вопрос. Теперь вы знаете намного больше, в частности про IP адресацию, DNS и т.д.
Опишите максимально подробно насколько вы это можете сделать, что происходит, когда вы делаете запрос `curl -I http://netology.ru` с вашей рабочей станции. Предположим, что arp кеш очищен, в локальном DNS нет закешированных записей.
    - **Проверяется, есть ли данный домен в кеше**
    - **Если домена нет, то отправляется запрос в dns-сервер**
    - **Если данная запись имеется, в ответ приходит ответ в ввиде ip адреса назначения**
    - **Далее отправляется запрос на ip адрес назначения полученный на предыдущем шаге**  
    - **Следующим шагом проверяется, содержится ли полученный ip в текущей подсети**
    - **Если в текущей подсети не содержится, то запрос отправляется в шлюз по умолчанию**
    - **Когда нужная подсеть была найдена, а так-же сервер с ip назначения, отправляется ответ**
    - **После того как был найден получаетель и с ним был установлен контакт, начинается передача основного запроса `sendto(5, "HEAD / HTTP/1.1\r\nHost: netology."..., 76, MSG_NOSIGNAL, NULL, 0) = 76`**
    - **В ответ приходит ответ `recvfrom(5, "HTTP/1.1 301 Moved Permanently\r\n"..., 102400, 0, NULL, NULL) = 397`**
    - **После этого соединение закрывается**

1. Сколько и каких итеративных запросов будет сделано при резолве домена `www.google.co.uk`?
    - **Для резолва данного домена, будет произведенно 4 запроса**

1. Сколько доступно для назначения хостам адресов в подсети `/25`? А в подсети с маской `255.248.0.0`. Постарайтесь потренироваться в ручных вычислениях чтобы немного набить руку, не пользоваться калькулятором сразу.
    - **В подсети с маской `/25` доступно 128 адресов**
    - **В подсети с маской `255.248.0.0` доступно 524288 адресов**

1. В какой подсети больше адресов, в `/23` или `/24`?
    - **В подсети с маской `/23` будет больше адресов**

1. Получится ли разделить диапазон `10.0.0.0/8` на 128 подсетей по 131070 адресов в каждой? Какая маска будет у таких подсетей?
    - **Да, получится, маска у таких подсетей будет `/15`**

# Доработка ДЗ

1. Задание 1, 2, 3: Предлагаю показать расчеты.
   - **Задание 1:**
      - **throughput = 1 Гбит/с = 1000000 бит**
      - **RTT = 300 мс = 0.3 c**
      - **RWIN = throughput * RTT = 1000000000 * 0.3 = 300000000 бит = 35.76 МБайт**
   - **Задание 2:**
      - **throughput = MSS / (RTT * sqrt(Ploss))**
      - **throughput = (1460 * 8) / (0.3 * sqrt(pow(10, -8))) = 389333 Кбит/с**
      - **throughput = (1460 * 8) / (0.3 * sqrt(1)) = 38 Кбит/с**
      - **Пропускная способность канала упадет в ~10000 раз**
   - **Задание 3:**
      - **Реальная скорость передачи = фактическая скорость - заголовки каждого переданного фрейма**
      - **В каждом фрейме стандартные заголовки занимают 40 бит, следовательно payload равен 1460 бит**
      - **1500 бит = 100%, 1460 бит следовательно примерно 97%**
      - **Исходя из произведенных вычислений получаем, что реальная скорость при фактической 100 Мбит/с равна 97 Мбит/с**
      - **В случае если один фрейм будет равен 5000 бит = 100%, то 4960 = 99%, то есть реальнас скорость будет равна 99Мбит/с**
      - **Следовательно при увеличении размера фрейма, реальная скорость увеличится, за счет того что потребуется меньше передавать заголовков**
1. Задание 4: Протоколы ARP и TCP как-то участвуют в обмене?
    - **Протокол ARP**
       - **Перед передачей фрейма идет проверка ARP кеша, для получения MAC адреса получаетля**
       - **Если в кеше данной информации нет, то выполняется шроковещательный запрос ARP**
       - **Когда получатель с необходимым IP-адресом принимает данный запрос, в ответ передает свой MAC**
       - **Отправитель записывает связку IP-адреса c MAC-фдресом получаетля в кеш**
    - **Протокол TCP**
       - **Клиент посылает серверу сегмент с номером последовательности и флагом SYN**
       - **Сервер получает сегмент и создает сокет**
       - **Отправляет в ответ инкрементированный номер последовательности и флаги SYN и ACK и переходит в состояние SYN-RECEIVED**
       - **Клмент получает сегмент, запоминает номер последовательности, переходит в состояние ESTABLISHED и отправляет сегмент с флагом ACK**
       - **Сервер получает сегмент с флагом ACK и переходит в состояние ESTABLISHED**
       - **После этого начинается передача данных**
       - **После того как все данные были переданны, клиент передает серверу фрейм с флагом FIN**
       - **Сервер посылает клиенту флаги ответа ACK, FIN**
       - **После получаение этих флагов, клиент закрывает соединение и в подтверждение отправляет серверу ACK**
       
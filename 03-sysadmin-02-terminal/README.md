# Домашнее задание к занятию "3.2. Работа в терминале, лекция 2"

1. Какого типа команда `cd`? Попробуйте объяснить, почему она именно такого типа; опишите ход своих мыслей, если считаете что она могла бы быть другого типа.
    - **Команда `cd` имеет тип вывода. Т.к. она выводит переданный путь и заменяет его в переменной текущего каталога пользователя**
1. Какая альтернатива без pipe команде `grep <some_string> <some_file> | wc -l`? `man grep` поможет в ответе на этот вопрос. Ознакомьтесь с [документом](http://www.smallo.ruhr.de/award.html) о других подобных некорректных вариантах использования pipe.
    - **`grep -c <some_string> <some_file>`**
1. Какой процесс с PID `1` является родителем для всех процессов в вашей виртуальной машине Ubuntu 20.04?
    - **Процесс с PID `1` имеет название `systemd`, выяснил это прочитав из файла `/proc/1/status`**
1. Как будет выглядеть команда, которая перенаправит вывод stderr `ls` на другую сессию терминала?
    - **`ls /root 2> /dev/pts/1` - где 1 получили выполнив команду `tty` или `ls /root 2> /proc/1138/fd/1` - где 1138 узнали выпонлив `echo $$`**
1. Получится ли одновременно передать команде файл на stdin и вывести ее stdout в другой файл? Приведите работающий пример.
    - **`cat path.txt | xargs ls > ls.txt`**
1. Получится ли вывести находясь в графическом режиме данные из PTY в какой-либо из эмуляторов TTY? Сможете ли вы наблюдать выводимые данные?
   - **Да, получится, а так же можно будет наблюдать. Выполнив команду: `echo test > /dev/tty`**
1. Выполните команду `bash 5>&1`. К чему она приведет? Что будет, если вы выполните `echo netology > /proc/$$/fd/5`? Почему так происходит?
    - **Данная команда приведет к созданию нового файлового дескриптора, который будет перенаправляться на стандартный поток вывода**
    - **При выполнении второй команды переданная строка выведится на экран. Это произойдет из-за перенаправления, которое мы создали выполнив предыдущую команду** 
1. Получится ли в качестве входного потока для pipe использовать только stderr команды, не потеряв при этом отображение stdout на pty? Напоминаем: по умолчанию через pipe передается только stdout команды слева от `|` на stdin команды справа.
Это можно сделать, поменяв стандартные потоки местами через промежуточный новый дескриптор, который вы научились создавать в предыдущем вопросе.
1. Что выведет команда `cat /proc/$$/environ`? Как еще можно получить аналогичный по содержанию вывод?
    - **Данная команда выведит переменные окружения текущего пользователя**
    - **Аналогичный вывод можно получить выполнив команду `env`**
1. Используя `man`, опишите что доступно по адресам `/proc/<PID>/cmdline`, `/proc/<PID>/exe`.
    - **По адресу `/proc/<PID>/cmdline` находится полная командная строка для указанного процесса**
    - **По адресу `/proc/<PID>/exe` находится символическая ссылка на фактический путь к выполняемой программе**
1. Узнайте, какую наиболее старшую версию набора инструкций SSE поддерживает ваш процессор с помощью `/proc/cpuinfo`.
    - **Мой процессор поддерживает наиболее страшую SSE с версией 4.2, а так-же расширение для AMD с версией 4a**
1. При открытии нового окна терминала и `vagrant ssh` создается новая сессия и выделяется pty. Это можно подтвердить командой `tty`, которая упоминалась в лекции 3.2. Однако:

    ```bash
	vagrant@netology1:~$ ssh localhost 'tty'
	not a tty
    ```

	Почитайте, почему так происходит, и как изменить поведение.
    - **Это происходит из-за того что по умолчанию на удаленной машине TTY не выделется, чтоб измнить поведение нужно добавить параметр `-t`, например: `ssh -t localhost 'tty'`**
1. Бывает, что есть необходимость переместить запущенный процесс из одной сессии в другую. Попробуйте сделать это, воспользовавшись `reptyr`. Например, так можно перенести в `screen` процесс, который вы запустили по ошибке в обычной SSH-сессии.
    - **Запустить какой-то процесс, я выполнил ls -lha в папке с большим количествам файлов**
    - **Остановил процесс `ctrl+Z`**
    - **Открыл новую сессию**
    - **Зашел в `screen`**
    - **Узнал номер PID команды ls**
    - **Вернулся в предыдущую сессию и запустил остановленную команду `bg`**  
    - **Выполнил команду `sudo reptyr -T PID(ls)`**
1. `sudo echo string > /root/new_file` не даст выполнить перенаправление под обычным пользователем, так как перенаправлением занимается процесс shell'а, который запущен без `sudo` под вашим пользователем. Для решения данной проблемы можно использовать конструкцию `echo string | sudo tee /root/new_file`. Узнайте что делает команда `tee` и почему в отличие от `sudo echo` команда с `sudo tee` будет работать.
    - **Команда `tee` используется для записи вывода команд в файл. Команда `sudo tee` будет работать т.к. выполнится с привилигированными правами, в отличии от обычного перенаправления**
    
# Доработка ДЗ

1. Задание 1, Предлагаю выполнить команду: type cd
    - **Команда `cd` являеться типом shell builtin. Реализованна так для избежания накладных расходов на загрузку программы**
1. Задание 5, xargs работает со списком параметров командной строки, в дз говорится о перенаправлении ввода-вывода. Попробуете подумать ещё?
    - **`cat < file1.txt > file2.txt`**
1. Не получилось выполнить? - **случайно пропустил**
Получится ли в качестве входного потока для pipe использовать только stderr команды, не потеряв при этом отображение stdout на pty? Напоминаем: по умолчанию через pipe передается только stdout команды слева от `|` на stdin команды справа.
Это можно сделать, поменяв стандартные потоки местами через промежуточный новый дескриптор, который вы научились создавать в предыдущем вопросе.
   - **В текущей директории создал два файла, один без доступа у текущего юзера, второй с доступом**
   - **`bash 5>&1`**
   - **`cat * 2>&1 >/proc/$$/fd/5 | tee errors.txt`**
   - **После выполнения вышенаписанной команды, вывелось на экран содержание файла к которому есть доступ, а в файл `errors.txt` записалась ошибка**